<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>IndieCert</title>
  <link rel="stylesheet" type="text/css" href="css/style.css">
</head>
<body>
    <div id="container">
    <a class="header" href="welcome"><h1>IndieCert</h1></a>

    <h2>Relying Party</h2>
    <p>
Here you can read how to integrate your service as a <em>relying party</em>
with IndieCert.
    </p>

    <h3>Authentication Request</h3>
    <p>
The relying party redirects the browser to <code>{{ authUri|e }}</code> to
initiate the authentication process. These query parameters MUST be specified:
    </p>

<dl>
    <dt><code>me</code></dt>
    <dd>
the URL to the user's home page, or host name, e.g.: <code>example.org</code>
or <code>https://www.example.org/john/</code>;
    </dd>
    <dt><code>redirect_uri</code></dt>
    <dd>
the callback URL belonging to the relying party where the browser will be
redirected back to after successful authentication and after user approval. It
MUST be an absolute HTTPS URL, e.g.: <code>https://example.org/callback</code>;
    </dd>
    <dt><code>state</code></dt>
    <dd>
a randomly generated nonce to be used as a CSRF token which MUST be freshly
generated for every call and MUST NEVER be repeated.
    </dd>
</dl>

    <p>
If the <code>me</code> field is not a valid HTTPS URI it will be modified by
adding <code>https://</code> to the front and optionally a
trailing <code>/</code> if it is just a domain. For example:
<code>example.org</code> will be modified to <code>https://example.org/</code>.
After (optional) modification of <code>me</code>, both <code>me</code> and
<code>redirect_uri</code> MUST point to absolute HTTPS resources. If the URL is
a HTTP URI or otherwise invalid it will be rejected.
    </p>
    
    <h4>Example</h4>
    <p>
The redirect to the authentication server can be accomplished by using a
redirect:
    </p>

<blockquote>
<pre>HTTP/1.1 302 Found
Location: {{ authUri|e }}?me=https://www.example.org/john/&amp;redirect_uri=https://example.org/callback&amp;state=PmctIM3J7O25NDSy
</pre>
</blockquote>

    <p>
or using a <code>&lt;form&gt;</code>:
    </p>
<blockquote>
<pre>
&lt;form method="get" action="{{ authUri|e }}"&gt;
    &lt;input type="hidden" name="redirect_uri" value="https://example.org/callback"&gt;
    &lt;input type="hidden" name="state" value="PmctIM3J7O25NDSy"&gt;
    &lt;input type="text" name="me" id="me" placeholder="example.org"&gt;
    &lt;input type="submit" value="Sign In"&gt;
&lt;/form&gt;
</pre>
</blockquote>
    <p>
Note that the <code>state</code> value MUST be generated fresh for every
authentication request and stored, e.g. in the user session, for later
validation when handling the authentication response to the callback.
    </p>
    
    <h3>Authentication Response</h3>
    <p>
IndieCert will redirect the browser back to the <code>redirect_uri</code>
specified in the authentication request after the user is authenticated at
IndieCert and approved the authentication.
    </p>

    <h4>Example</h4>

<blockquote>
<pre>
HTTP/1.1 302 Found
Location: https://example.org/callback?code=wW3OLXJZn35d7zFwg9YGmWti&amp;state=PmctIM3J7O25NDSy
</pre>
</blockquote>
 
    <h3>Verification Request</h3>
    <p>
After verifying that the <code>state</code> parameter matches the value sent
during the authentication request, the <code>code</code> parameter can now be
used to verify the claimed user identity. The <code>code</code> is valid for
10 minutes and can be used only once. The following parameters MUST be
specified:
    </p>

<dl>
    <dt><code>code</code></dt>
    <dd>
the code obtained in the authentication response query parameter
<code>code</code>;
    </dd>

    <dt><code>redirect_uri</code></dt>
    <dd>
the URL the browser was redirected back to after the successful authentication,
e.g.: <code>https://example.org/callback</code>.
    </dd>
</dl>
<p>
Now a HTTPS <code>POST</code> can be used to obtain the user's home page URL:
    </p>
<blockquote>
<pre>
POST {{ verifyPath|e}} HTTP/1.1
Host: {{ hostName|e }}
Accept: application/json
Content-Type: application/x-www-form-urlencoded

code=wW3OLXJZn35d7zFwg9YGmWti&amp;redirect_uri=https%3A%2F%2Fexample.org%2Fcallback
</pre>
</blockquote>

    <p>
The response will be returned as <code>application/json</code> or
<code>application/x-www-form-urlencoded</code> depending on <code>Accept</code>
header. The default is currently <code>application/x-www-form-urlencoded</code>.
    </p>

    <p>
The <code>me</code> field in the response is the identity that MUST be used by
the relying party to identify the user as it MAY differ from the initial
<code>me</code> specified by the user, e.g.: <code>https://</code> was added,
or the default path <code>/</code> was added.
    </p>
    <p>
The examples below are using the <code>application/json</code> format.
    </p>

<blockquote>
<pre>
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache

{
    "me": "https://www.example.org/john/"
}
</pre>
</blockquote>

    <p>
In case there was a failure in verifying the code, e.g. it was already used, or
not valid the following response can be expected:
    </p>

<blockquote>
<pre>
HTTP/1.1 400 Bad Request
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache

{
    "error":"invalid_request"
}
</pre>
</blockquote>

    <h3>Security Considerations</h3>
    <h4>CSRF</h4>
    <p>
The CSRF attack we try to prevent is the attack where user X tricks user Y to
authenticate to a relying party using an account under user X's control. The
danger is unintentionally leaking private date to the account under X's
control, e.g. private pictures.
    </p>
    <p>
Using and validating the <code>state</code> in the authentication request and
response is sufficient to prevent this CSRF.
    </p>

    <div class="footer">
        <a href="faq">FAQ</a> | IndieCert
    </div>
    </div>
</body>
</html>
